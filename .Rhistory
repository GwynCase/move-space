# Pull out just RLK.
rlk.buffer.400 <- filter(nest.buffer.400, site == 'RLK' & year == 2019)
# Find the difference with the telemetry points.
rlk.foraging.400 <- st_difference(rlk.sf, rlk.buffer.400)
# Do the annoying data frame thing again.
rlk.foraging.c.400 <- rlk.foraging.400 %>% mutate(xcoord = unlist(map(rlk.foraging.400$geometry,1)),
ycoord = unlist(map(rlk.foraging.400$geometry,2))) %>%
data.frame() %>%
select(xcoord, ycoord, datetime, id)
# Calculate revisits, using 150m.
foraging.visits.400 <- getRecursions(rlk.foraging.c.400, 150)
# Make a data frame for ease.
revisits.400 <- data.frame(foraging.visits.400$revisitStats)
# Plot it.
ggplot(revisits.400, aes(x=x, y=y, color=as.factor(visitIdx))) +
geom_point() +
scale_color_brewer(palette="RdYlBu", direction=-1) +
theme_void()
# Pull out just the RLK nest coords.
rlk.nest <- read_csv('../data/processed/telemetry_sites.csv') %>%
filter(site == 'RLK' & year == 2019) %>%
select(x_coord, y_coord) %>%
data.frame()
## Note that recuse require this to be a data frame ONLY (no tibbles allowed).
# Calculate revisits.
nest.visits <- getRecursionsAtLocations(rlk.sf.c, rlk.nest, radius=400)
# Pull out the important stuff.
visit.stats <- nest.visits$revisitStats %>%
mutate(time=round_date(entranceTime, unit='hour')) %>%
mutate(time=format(time, '%H:%M:%S')) %>%
mutate(date=date(entranceTime))
ggplot(visit.stats, aes(x=timeInside)) +
geom_density() +
theme_classic()
ggplot(visit.stats, aes(x=time, y=timeInside)) +
geom_boxplot() +
theme_classic() +
geom_jitter(alpha=0.25) +
labs(x='entrance time', y='visit duration')
ggplot(visit.stats, aes(x=timeSinceLastVisit)) +
geom_density() +
theme_classic()
ggplot(visit.stats, aes(x=timeSinceLastVisit, y=timeInside)) +
geom_point() +
theme_classic()
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE)
# Import conflict settings.
source('../src/conflicted.R')
#Load some libraries.
library(tidyverse)
library(sf)
library(lubridate)
library(adehabitatHR)
library(ggplot2)
library(extrafont)
library(recurse)
# Define some colors.
m <- '#d36135' # Flame
f <- '#689689' # Polished pine
# Load telemetry data.
tl <- read_csv('../data/processed/telemetry_2018-2019.csv')
# RLK appears to have been missexed. I'll change that here.
tl <- tl %>% mutate(sex = case_when(
id == 'HAR04' ~ 'm',
TRUE ~ sex
))
# Define breeding season.
breeding.2018 <- interval(ymd(20180511), ymd(20180901))
breeding.2019 <- interval(ymd(20190511), ymd(20190901))
# Select only points that fall within the breeding season.
tl.breeding <- tl %>%
filter(date %within% c(breeding.2018, breeding.2019))
# Summarize.
tl.breeding %>% group_by(id) %>%
mutate(min=min(date), max=max(date), n.points=n(), period=max-min) %>%
distinct(id, sex, site, n.points, min, max, period)
tl.breeding %>% group_by(id) %>%
mutate(t.points=n(), base.points=sum(at.base), base.prop=base.points/t.points*100) %>%
distinct(id, sex, site, base.prop)
tl.breeding %>% group_by(id) %>%
mutate(t.points=n(), base.points=sum(at.base), base.prop=base.points/t.points*100) %>%
distinct(id, sex, site, base.prop) %>%
group_by(sex) %>% mutate(mean.nest.time=mean(base.prop)) %>%
distinct(sex, mean.nest.time)
# Convert data to spatial object.
tl.sf <- tl.breeding %>% st_as_sf(coords=c('lon', 'lat')) %>%
st_set_crs('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs') %>%
st_transform("+proj=utm +zone=10 +datum=WGS84 +units=m +no_defs")
View(tl.breeding)
# Covert back to data frame so recurse can eat it.
tl.c <- tl.sf %>% mutate(xcoord = unlist(map(tl.sf$geometry,1)),
ycoord = unlist(map(tl.sf$geometry,2))) %>%
data.frame() %>%
select(xcoord, ycoord, datetime, id)
View(tl.c)
# Bring in nest coordinates.
nests <- read_csv('../data/processed/telemetry_sites.csv') %>%
select(x_coord, y_coord) %>%
data.frame()
# Calculate revisits.
nest.visits <- getRecursionsAtLocations(tl.c, nests, radius=400)
View(nest.visits)
# Pull out the important stuff.
visit.stats <- nest.visits$revisitStats %>%
mutate(time=round_date(entranceTime, unit='hour')) %>%
mutate(time=format(time, '%H:%M:%S')) %>%
mutate(date=date(entranceTime))
head(visit.stats)
ggplot(visit.stats, aes(x=timeInside)) +
geom_density() +
theme_classic() +
facet_wrap(~id)
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeInside))
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit))
visit.stats %>% group_by(id) %>%
drop_na(timeSinceLastVisit) %>%
summarize(mean=mean(timeSinceLastVisit))
visit.stats %>% group_by(id) %>%
#drop_na(timeSinceLastVisit) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE))
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
quant=quantile(timeSinceLastVisit))
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
quant=quantile(timeSinceLastVisit, na.rm=TRUE))
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
quantile=quantile(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit, na.rm=TRUE),
max=max(timeSinceLastVisit, na.rm=TRUE))
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
quantile=quantile(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit),
max=max(timeSinceLastVisit))
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit))
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
min=min())
visit.stats %>% group_by(id) %>%
summarize(mn=min(timeSinceLastVisit))
visit.stats$timeSinceLastVisit
visit.stats$timeSinceLastVisit %>% mint()
visit.stats$timeSinceLastVisit %>% min()
visit.stats$timeSinceLastVisit %>% drop_na()
visit.stats %>% drop_na(timeSinceLastVisit)
visit.stats %>% drop_na(timeSinceLastVisit) %>%
summarize(min(timeSinceLastVisit))
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE)) %>%
drop_na(timeSinceLastVisit)
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit))
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit, na.rm=TRUE))
visit.stats %>% group_by(id) %>%
summarize(min=min(timeSinceLastVisit, na.rm=TRUE))
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit, na.rm=TRUE),
max=max(timeSinceLastVisit, na.rm=TRUE))
visit.stats %>% distinct(id)
tl.breeding %>% distinct(id)
tl.c %>% distinct(id)
View(nests)
# Bring in nest coordinates.
nests <- read_csv('../data/processed/telemetry_sites.csv') %>%
filter(year == 2019) %>%
select(x_coord, y_coord) %>%
data.frame()
# Calculate revisits.
nest.visits <- getRecursionsAtLocations(tl.c, nests, radius=400)
# Pull out the important stuff.
visit.stats <- nest.visits$revisitStats %>%
mutate(time=round_date(entranceTime, unit='hour')) %>%
mutate(time=format(time, '%H:%M:%S')) %>%
mutate(date=date(entranceTime))
visit.stats %>% distinct(id)
n.full <- read_csv('../data/processed/telemetry_sites.csv')
n.full <- read_csv('../data/processed/telemetry_sites.csv')
View(n.full)
# Calculate revisits.
nest.visits <- getRecursionsAtLocations(tl.c, nests, radius=400)
View(nest.visits)
nest.visits[["revisitStats"]][["id"]] %>% distinct()
view(nest.visits[["revisitStats"]][["id"]])
# Look at some summaries.
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit, na.rm=TRUE),
max=max(timeSinceLastVisit, na.rm=TRUE))
163/24
# Look at some summaries.
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit, na.rm=TRUE),
max=max(timeSinceLastVisit, na.rm=TRUE))
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE)
# Import conflict settings.
source('../src/conflicted.R')
#Load some libraries.
library(tidyverse)
library(sf)
library(lubridate)
library(adehabitatHR)
library(ggplot2)
library(extrafont)
library(recurse)
# Define some colors.
m <- '#d36135' # Flame
f <- '#689689' # Polished pine
# Load telemetry data.
tl <- read_csv('../data/processed/telemetry_2018-2019.csv')
# RLK appears to have been missexed. I'll change that here.
tl <- tl %>% mutate(sex = case_when(
id == 'HAR04' ~ 'm',
TRUE ~ sex
))
# Define breeding season.
breeding.2018 <- interval(ymd(20180511), ymd(20180901))
breeding.2019 <- interval(ymd(20190511), ymd(20190901))
# Select only points that fall within the breeding season.
tl.breeding <- tl %>%
filter(date %within% c(breeding.2018, breeding.2019))
# Summarize.
tl.breeding %>% group_by(id) %>%
mutate(min=min(date), max=max(date), n.points=n(), period=max-min) %>%
distinct(id, sex, site, n.points, min, max, period)
tl.breeding %>% group_by(id) %>%
mutate(t.points=n(), base.points=sum(at.base), base.prop=base.points/t.points*100) %>%
distinct(id, sex, site, base.prop)
tl.breeding %>% group_by(id) %>%
mutate(t.points=n(), base.points=sum(at.base), base.prop=base.points/t.points*100) %>%
distinct(id, sex, site, base.prop) %>%
group_by(sex) %>% mutate(mean.nest.time=mean(base.prop)) %>%
distinct(sex, mean.nest.time)
# Convert data to spatial object.
tl.sf <- tl.breeding %>% st_as_sf(coords=c('lon', 'lat')) %>%
st_set_crs('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs') %>%
st_transform("+proj=utm +zone=10 +datum=WGS84 +units=m +no_defs")
# Covert back to data frame so recurse can eat it.
tl.c <- tl.sf %>% mutate(xcoord = unlist(map(tl.sf$geometry,1)),
ycoord = unlist(map(tl.sf$geometry,2))) %>%
data.frame() %>%
select(xcoord, ycoord, datetime, id)
# Bring in nest coordinates.
nests <- read_csv('../data/processed/telemetry_sites.csv') %>%
filter(year == 2019) %>%
select(x_coord, y_coord) %>%
data.frame()
# Calculate revisits.
nest.visits <- getRecursionsAtLocations(tl.c, nests, radius=400)
# Pull out the important stuff.
visit.stats <- nest.visits$revisitStats %>%
mutate(time=round_date(entranceTime, unit='hour')) %>%
mutate(time=format(time, '%H:%M:%S')) %>%
mutate(date=date(entranceTime))
# Look at some summaries.
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit, na.rm=TRUE),
max=max(timeSinceLastVisit, na.rm=TRUE))
View(nest.visits)
View(nests)
read_csv('../data/processed/telemetry_sites.csv') %>%
filter(year == 2019) #%>%
nn <- read_csv('../data/processed/telemetry_sites.csv')
nn %>%
filter(year == 2019) #%>%
View(nn)
nn %>%
filter(year != 2020) #%>%
tl.breeding %>% distinct(id)
visit.stats %>% distinct(id)
ska.nest <- nn %>%
filter(site == 'SKA') %>%
select(x_coord, y_coord) %>%
data.frame()
ska.visits <- getRecursionsAtLocations(tl.c, ska.nest, radius=400)
View(ska.visits)
ska.stats <- ska.visits$revisitStats %>%
mutate(time=round_date(entranceTime, unit='hour')) %>%
mutate(time=format(time, '%H:%M:%S')) %>%
mutate(date=date(entranceTime))
View(ska.stats)
tl %>% distinct(id, site)
rlk.nest <- nn %>%
filter(site == 'RLK' & year == 2019) %>%
select(x_coord, y_coord) %>%
data.frame()
rlk.visits <- getRecursionsAtLocations(tl.c, rlk.nest, radius=400)
rlk.stats <- rlk.visits$revisitStats %>%
mutate(time=round_date(entranceTime, unit='hour')) %>%
mutate(time=format(time, '%H:%M:%S')) %>%
mutate(date=date(entranceTime))
View(rlk.stats)
View(nn)
nn.sf <- nn %>% st_as_sf(coords=c('x_coord', 'y_coord')) %>%
st_set_crs("+proj=utm +zone=10 +datum=WGS84 +units=m +no_defs")
ggplot() +
geom_sf(data=nn.sf)
ggplot() +
geom_sf(data=nn.sf) +
geom_text(data=nn.sf, aes(x_coord, y_coord, label=nest))
ggplot() +
geom_sf(data=nn.sf) +
geom_text(data=nn, aes(x_coord, y_coord, label=nest))
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE)
# Import conflict settings.
source('../src/conflicted.R')
#Load some libraries.
library(tidyverse)
library(sf)
library(lubridate)
library(adehabitatHR)
library(ggplot2)
library(extrafont)
library(recurse)
# Define some colors.
m <- '#d36135' # Flame
f <- '#689689' # Polished pine
# Load telemetry data.
tl <- read_csv('../data/processed/telemetry_2018-2019.csv')
# RLK appears to have been missexed. I'll change that here.
tl <- tl %>% mutate(sex = case_when(
id == 'HAR04' ~ 'm',
TRUE ~ sex
))
# Define breeding season.
breeding.2018 <- interval(ymd(20180511), ymd(20180901))
breeding.2019 <- interval(ymd(20190511), ymd(20190901))
# Select only points that fall within the breeding season.
tl.breeding <- tl %>%
filter(date %within% c(breeding.2018, breeding.2019))
# Summarize.
tl.breeding %>% group_by(id) %>%
mutate(min=min(date), max=max(date), n.points=n(), period=max-min) %>%
distinct(id, sex, site, n.points, min, max, period)
tl.breeding %>% group_by(id) %>%
mutate(t.points=n(), base.points=sum(at.base), base.prop=base.points/t.points*100) %>%
distinct(id, sex, site, base.prop)
tl.breeding %>% group_by(id) %>%
mutate(t.points=n(), base.points=sum(at.base), base.prop=base.points/t.points*100) %>%
distinct(id, sex, site, base.prop) %>%
group_by(sex) %>% mutate(mean.nest.time=mean(base.prop)) %>%
distinct(sex, mean.nest.time)
# Convert data to spatial object.
tl.sf <- tl.breeding %>% st_as_sf(coords=c('lon', 'lat')) %>%
st_set_crs('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs') %>%
st_transform("+proj=utm +zone=10 +datum=WGS84 +units=m +no_defs")
# Covert back to data frame so recurse can eat it.
tl.c <- tl.sf %>% mutate(xcoord = unlist(map(tl.sf$geometry,1)),
ycoord = unlist(map(tl.sf$geometry,2))) %>%
data.frame() %>%
select(xcoord, ycoord, datetime, id)
# Bring in nest coordinates.
nests <- read_csv('../data/processed/telemetry_sites.csv') %>%
filter(year == 2019) %>%
select(x_coord, y_coord) %>%
data.frame()
# Calculate revisits.
nest.visits <- getRecursionsAtLocations(tl.c, nests, radius=400)
# Pull out the important stuff.
visit.stats <- nest.visits$revisitStats %>%
mutate(time=round_date(entranceTime, unit='hour')) %>%
mutate(time=format(time, '%H:%M:%S')) %>%
mutate(date=date(entranceTime))
# Look at some summaries.
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit, na.rm=TRUE),
max=max(timeSinceLastVisit, na.rm=TRUE))
# Manually fix HAR04 w
View(visit.stats)
ggplot(visit.stats, aes(x=date, y=timeSinceLastVisit)) +
geom_point() +
theme_classic()
ggplot(visit.stats, aes(x=date, y=timeSinceLastVisit)) +
geom_point() +
theme_classic() +
facet_wrap(~id)
ggplot(visit.stats, aes(x=date, y=timeSinceLastVisit)) +
geom_point() +
theme_classic() +
facet_wrap(~id, scales='free')
ggplot(visit.stats, aes(x=date, y=timeInside)) +
geom_point() +
theme_classic() +
facet_wrap(~id, scales='free')
ggplot(visit.stats, aes(x=time)) +
geom_boxplot() +
theme_classic() +
geom_jitter(alpha=0.25) +
facet_wrap(~id, scales='free')
ggplot(visit.stats, aes(x=time, y=timeInside)) +
geom_boxplot() +
theme_classic() +
geom_jitter(alpha=0.25) +
facet_wrap(~id, scales='free')
ggplot(visit.stats, aes(x=time)) +
geom_density() +
theme_classic() +
facet_wrap(~id, scales='free')
visit.stats %>% drop_na(time) %>%
ggplot(aes(x=time)) +
geom_density() +
theme_classic()
ggplot(visit.stats, aes(x=time)) +
geom_density() +
theme_classic() +
facet_wrap(~id, scales='free')
visit.stats %>% filter(id == 'HAR04') %>%
ggplot(aes(x=time)) +
geom_histogram() +
theme_classic()
visit.stats %>% filter(id == 'HAR04') %>%
ggplot(aes(x=time)) +
geom_histogram(stat='count') +
theme_classic()
ggplot(visit.stats, aes(x=time)) +
geom_histogram(stat='count') +
theme_classic() +
facet_wrap(~id, scales='free')
ggplot(visit.stats, aes(x=time)) +
geom_histogram(stat='count') +
theme_classic() +
facet_wrap(~id)
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE)
# Import conflict settings.
source('../src/conflicted.R')
#Load some libraries.
library(tidyverse)
library(sf)
library(lubridate)
library(adehabitatHR)
library(ggplot2)
library(extrafont)
library(recurse)
# Define some colors.
m <- '#d36135' # Flame
f <- '#689689' # Polished pine
# Load telemetry data.
tl <- read_csv('../data/processed/telemetry_2018-2019.csv')
# RLK appears to have been missexed. I'll change that here.
tl <- tl %>% mutate(sex = case_when(
id == 'HAR04' ~ 'm',
TRUE ~ sex
))
# Define breeding season.
breeding.2018 <- interval(ymd(20180511), ymd(20180901))
breeding.2019 <- interval(ymd(20190511), ymd(20190901))
# Select only points that fall within the breeding season.
tl.breeding <- tl %>%
filter(date %within% c(breeding.2018, breeding.2019))
# Summarize.
tl.breeding %>% group_by(id) %>%
mutate(min=min(date), max=max(date), n.points=n(), period=max-min) %>%
distinct(id, sex, site, n.points, min, max, period)
tl.breeding %>% group_by(id) %>%
mutate(t.points=n(), base.points=sum(at.base), base.prop=base.points/t.points*100) %>%
distinct(id, sex, site, base.prop)
tl.breeding %>% group_by(id) %>%
mutate(t.points=n(), base.points=sum(at.base), base.prop=base.points/t.points*100) %>%
distinct(id, sex, site, base.prop) %>%
group_by(sex) %>% mutate(mean.nest.time=mean(base.prop)) %>%
distinct(sex, mean.nest.time)
# Convert data to spatial object.
tl.sf <- tl.breeding %>% st_as_sf(coords=c('lon', 'lat')) %>%
st_set_crs('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs') %>%
st_transform("+proj=utm +zone=10 +datum=WGS84 +units=m +no_defs")
# Covert back to data frame so recurse can eat it.
tl.c <- tl.sf %>% mutate(xcoord = unlist(map(tl.sf$geometry,1)),
ycoord = unlist(map(tl.sf$geometry,2))) %>%
data.frame() %>%
select(xcoord, ycoord, datetime, id)
# Bring in nest coordinates.
nests <- read_csv('../data/processed/telemetry_sites.csv') %>%
filter(year == 2019) %>%
select(x_coord, y_coord) %>%
data.frame()
# Calculate revisits.
nest.visits <- getRecursionsAtLocations(tl.c, nests, radius=400)
# Pull out the important stuff.
visit.stats <- nest.visits$revisitStats %>%
mutate(time=round_date(entranceTime, unit='hour')) %>%
mutate(time=format(time, '%H:%M:%S')) %>%
mutate(date=date(entranceTime))
# Look at some summaries.
visit.stats %>% group_by(id) %>%
summarize(mean=mean(timeSinceLastVisit, na.rm=TRUE),
min=min(timeSinceLastVisit, na.rm=TRUE),
max=max(timeSinceLastVisit, na.rm=TRUE))
# Dig into that a bit more.
ggplot(visit.stats, aes(x=date, y=timeSinceLastVisit)) +
geom_point() +
theme_classic() +
facet_wrap(~id, scales='free')
ggplot(visit.stats, aes(x=date, y=timeInside)) +
geom_point() +
theme_classic() +
facet_wrap(~id, scales='free')
ggplot(visit.stats, aes(x=time)) +
geom_histogram(stat='count') +
theme_classic() +
facet_wrap(~id)
